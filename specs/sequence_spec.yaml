before:
  this_module = "prototype.sequence"
  M           = require (this_module)
  Sequence    = M.prototype
  l           = Sequence {"foo", "bar", "baz"}


specify prototype.sequence:
- context when required:
  - context by name:
    - it does not perturb the global namespace:
        expect (show_apis {added_to="_G", by="prototype.sequence"}).to_equal {}
  - context via the prototype module:
    - it does not perturb the global namespace:
        expect (show_apis {added_to="_G", by="prototype"}).to_equal {}


- describe construction:
  - context from Sequence clone method:
    - it constructs a new sequence:
        l = Sequence:clone {}
        expect (l).not_to_be (Sequence)
        expect (objtype (l)).to_be "Sequence"
    - it reuses the Sequence metatable:
        l, m = Sequence:clone {"l"}, Sequence:clone {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises Sequence with constructor parameters:
        m = Sequence:clone {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l:clone {}
        expect (objtype (m)).to_be "Sequence"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))

  # Sequence {args} is just syntactic sugar for Sequence:clone {args}
  - context from Sequence object prototype:
    - it constructs a new Sequence:
        l = Sequence {}
        expect (l).not_to_be (Sequence)
        expect (objtype (l)).to_be "Sequence"
    - it reuses the Sequence metatable:
        l, m = Sequence {"l"}, Sequence {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises Sequence with constructor parameters:
        m = Sequence {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l {}
        expect (objtype (m)).to_be "Sequence"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))


- describe metatable propagation:
  - it reuses the metatable for Sequence constructed objects:
      m = Sequence {"foo", "bar"}
      expect (getmetatable (m)).to_be (getmetatable (l))


- describe append:
  - before:
      f = M.append

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.append (Sequence, any)")

  - context as a module function:
    - it returns a Sequence object:
        expect (objtype (f (l, "quux"))).to_be "Sequence"
    - it works for an empty Sequence:
        expect (f (Sequence {}, "quux")).to_equal (Sequence {"quux"})
    - it appends an item to a Sequence:
        expect (f (l, "quux")).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})

  - context as an object method:
    - before:
        f = l.append

    - it returns a Sequence object:
        expect (objtype (f (l, "quux"))).to_be "Sequence"
    - it works for an empty Sequence:
        expect (f (Sequence {}, "quux")).to_equal (Sequence {"quux"})
    - it appends an item to a Sequence:
        expect (f (l, "quux")).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})

  - context as a Sequence metamethod:
    - it returns a Sequence object:
        expect (objtype (l + "quux")).to_be "Sequence"
    - it works for an empty sequence:
        expect (Sequence {} + "quux").to_equal (Sequence {"quux"})
    - it appends an item to a sequence:
        expect (l + "quux").
          to_equal (Sequence {"foo", "bar", "baz", "quux"})


- describe compare:
  - before:
      a, b = Sequence {"foo", "bar"}, Sequence {"foo", "baz"}

      f = M.compare

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.compare (Sequence, Sequence|table)")

  - context as a module function:
    - it returns -1 when the first sequence is less than the second:
        expect (f (a, {"foo", "baz"})).to_be (-1)
        expect (f (a, Sequence {"foo", "baz"})).to_be (-1)
    - it returns -1 when the second sequence has additional elements:
        expect (f (Sequence {"foo"}, {"foo", "bar"})).to_be (-1)
        expect (f (Sequence {"foo"}, Sequence {"foo", "bar"})).to_be (-1)
    - it returns 0 when two sequences are the same:
        expect (f (a, {"foo", "bar"})).to_be (0)
        expect (f (a, Sequence {"foo", "bar"})).to_be (0)
    - it returns +1 when the first sequence is greater than the second:
        expect (f (a, {"baz", "quux"})).to_be (1)
        expect (f (a, Sequence {"baz", "quux"})).to_be (1)
    - it returns +1 when the first sequence has additional elements:
        expect (f (a, {"foo"})).to_be (1)
        expect (f (a, Sequence {"foo"})).to_be (1)
    - it compares numerically when both arguments can be coerced:
        a, b = Sequence {"1", "2", "3"}, Sequence {"1", "2", "10"}
        expect (f (a, b)).to_be (-1)

  - context as an object method:
    - before:
        f = a.compare

    - it returns -1 when the first sequence is less than the second:
        expect (f (a, {"foo", "baz"})).to_be (-1)
        expect (f (a, Sequence {"foo", "baz"})).to_be (-1)
    - it returns -1 when the second sequence has additional elements: |
        b = Sequence {"foo"}
        expect (f (b, {"foo", "bar"})).to_be (-1)
        expect (Sequence {"foo"}:compare (Sequence {"foo", "bar"})).to_be (-1)
    - it returns 0 when two sequences are the same:
        expect (f (a, {"foo", "bar"})).to_be (0)
        expect (f (a, Sequence {"foo", "bar"})).to_be (0)
    - it returns +1 when the first sequence is greater than the second:
        expect (f (a, {"baz", "quux"})).to_be (1)
        expect (f (a, Sequence {"baz", "quux"})).to_be (1)
    - it returns +1 when the first sequence has additional elements:
        expect (f (a, {"foo"})).to_be (1)
        expect (f (a, Sequence {"foo"})).to_be (1)
    - it compares numerically when both arguments can be coerced:
        a, b = Sequence {"1", "2", "3"}, Sequence {"1", "2", "10"}
        expect (f (a, b)).to_be (-1)

  - context as a '<' Sequence metamethod:
    - it succeeds when the first sequence is less than the second:
        expect (a < b).to_be (true)
    - it fails when the first sequence is not less than the second:
        expect (a < a).to_be (false)
        expect (b < a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = Sequence {"1", "2", "3"}, Sequence {"1", "2", "10"}
        expect (a < b).to_be (true)

  - context as a '>' Sequence metamethod:
    - it succeeds when the first sequence is greater than the second:
        expect (b > a).to_be (true)
    - it fails when the first sequence is not greater than the second:
        expect (b > b).to_be (false)
        expect (a > b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = Sequence {"1", "2", "3"}, Sequence {"1", "2", "10"}
        expect (a > b).to_be (false)

  - context as a '<=' Sequence metamethod:
    - it succeeds when the first sequence is less than or equal to the second:
        expect (a <= b).to_be (true)
        expect (a <= a).to_be (true)
    - it fails when the first sequence is not less than or equal to the second:
        expect (b <= a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = Sequence {"1", "2", "3"}, Sequence {"1", "2", "10"}
        expect (a <= b).to_be (true)

  - context as a '>=' Sequence metamethod:
    - it succeeds when the first sequence is greater than or equal to the second:
        expect (b >= a).to_be (true)
        expect (b >= b).to_be (true)
    - it fails when the first sequence is not greater than or equal to the second:
        expect (a >= b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = Sequence {"1", "2", "3"}, Sequence {"1", "2", "10"}
        expect (a >= b).to_be (false)


- describe concat:
  - before:
      l = Sequence {"foo", "bar"}

      f = M.concat

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.concat (Sequence, Sequence|table*)")

  - context as a module function:
    - it returns a Sequence object:
        expect (objtype (f (l, l))).to_be "Sequence"
    - it works for an empty Sequence:
        expect (f (Sequence {}, {"baz"})).to_equal (Sequence {"baz"})
        expect (f (Sequence {}, Sequence {"baz"})).to_equal (Sequence {"baz"})
    - it concatenates Sequences:
        expect (f (l, {"baz", "quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (f (l, Sequence {"baz", "quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (f (l, {"baz"}, {"quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (f (l, Sequence {"baz"}, Sequence {"quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})

  - context as an object method:
    - before:
        f = l.concat

    - it returns a Sequence object:
        expect (objtype (f (l, l))).to_be "Sequence"
    - it works for an empty Sequence:
        expect (f (Sequence {}, {"baz"})).to_equal (Sequence {"baz"})
        expect (f (Sequence {}, Sequence {"baz"})).to_equal (Sequence {"baz"})
    - it concatenates Sequences:
        expect (f (l, {"baz", "quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (f (l, Sequence {"baz", "quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (f (l, {"baz"}, {"quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (f (l, Sequence {"baz"}, Sequence {"quux"})).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})

  # Beware that .. operations are right associative
  - context as a Sequence metamethod:
    - it returns a Sequence object:
        expect (objtype (l .. Sequence {"baz"})).to_be "Sequence"
    - it works for an empty Sequence:
        expect (Sequence {} .. {"baz"}).to_equal (Sequence {"baz"})
        expect (Sequence {} .. Sequence {"baz"}).to_equal (Sequence {"baz"})
    - it concatenates Sequences:
        expect (l .. {"baz", "quux"}).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect (l .. Sequence {"baz", "quux"}).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})
        expect ({"baz"} .. {"quux"} .. l).
          to_equal (Sequence {"baz", "quux", "foo", "bar"})
        expect (l .. Sequence {"baz"} .. Sequence {"quux"}).
          to_equal (Sequence {"foo", "bar", "baz", "quux"})


- describe cons:
  - before:
      f = M.cons

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.cons (Sequence, any)")

  - context as a module function:
    - it returns a Sequence object:
        expect (objtype (f (l, "x"))).to_be "Sequence"
    - it prepends an item to a Sequence:
        expect (f (l, "x")).to_equal (Sequence {"x", "foo", "bar", "baz"})
    - it works for empty Sequences:
        expect (f (Sequence {}, "x")).to_equal (Sequence {"x"})

  - context as an object method:
    - before:
        f = l.cons

    - it returns a Sequence object:
        expect (objtype (f (l, "x"))).to_be "Sequence"
    - it prepends an item to a Sequence:
        expect (f (l, "x")).to_equal (Sequence {"x", "foo", "bar", "baz"})
    - it works for empty Sequences:
        expect (f (Sequence {}, "x")).to_equal (Sequence {"x"})


- describe rep:
  - before:
      l = Sequence {"foo", "bar"}

      f = M.rep

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.rep (Sequence, int)")

  - context as a module function:
    - it returns a Sequence object:
        expect (objtype (f (l, 3))).to_be "Sequence"
    - it works for an empty Sequence:
        expect (f (Sequence {}, 99)).to_equal (Sequence {})
    - it repeats the contents of a Sequence:
        expect (f (l, 3)).
          to_equal (Sequence {"foo", "bar", "foo", "bar", "foo", "bar"})

  - context as an object method:
    - before:
        f = l.rep

    - it returns a Sequence object:
        expect (objtype (f (l, 3))).to_be "Sequence"
    - it works for an empty Sequence:
        expect (f (Sequence {}, 99)).to_equal (Sequence {})
    - it repeats the contents of a Sequence:
        expect (f (l, 3)).
          to_equal (Sequence {"foo", "bar", "foo", "bar", "foo", "bar"})


- describe sub:
  - before:
      l = Sequence {1, 2, 3, 4, 5, 6, 7}

      f = M.sub

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.sub (Sequence, ?int, ?int)")

  - context as a module function:
    - it returns a Sequence object:
        expect (objtype (f (l, 1, 1))).to_be "Sequence"
    - it makes a Sequence from a subrange of another Sequence:
        expect (f (l, 2, 5)).to_equal (Sequence {2, 3, 4, 5})
    - it truncates the result if 'to' argument is too large:
        expect (f (l, 5, 10)).to_equal (Sequence {5, 6, 7})
    - it defaults 'to' to the end of the Sequence:
        expect (f (l, 5)).to_equal (Sequence {5, 6, 7})
    - it defaults 'from' to the beginning of the Sequence:
        expect (f (l)).to_equal (l)
    - it returns an empty Sequence when 'from' is greater than 'to':
        expect (f (l, 2, 1)).to_equal (Sequence {})
    - it counts from the end of the Sequence for a negative 'from' argument:
        expect (f (l, -3)).to_equal (Sequence {5, 6, 7})
    - it counts from the end of the Sequence for a negative 'to' argument:
        expect (f (l, -5, -2)).to_equal (Sequence {3, 4, 5, 6})

  - context as an object method:
    - before:
        f = l.sub

    - it returns a Sequence object:
        expect (objtype (f (l, 1, 1))).to_be "Sequence"
    - it makes a Sequence from a subrange of another Sequence:
        expect (f (l, 2, 5)).to_equal (Sequence {2, 3, 4, 5})
    - it truncates the result if 'to' argument is too large:
        expect (f (l, 5, 10)).to_equal (Sequence {5, 6, 7})
    - it defaults 'to' to the end of the Sequence:
        expect (f (l, 5)).to_equal (Sequence {5, 6, 7})
    - it defaults 'from' to the beginning of the Sequence:
        expect (f (l)).to_equal (l)
    - it returns an empty Sequence when 'from' is greater than 'to':
        expect (f (l, 2, 1)).to_equal (Sequence {})
    - it counts from the end of the Sequence for a negative 'from' argument:
        expect (f (l, -3)).to_equal (Sequence {5, 6, 7})
    - it counts from the end of the Sequence for a negative 'to' argument:
        expect (f (l, -5, -2)).to_equal (Sequence {3, 4, 5, 6})


- describe tail:
  - before:
      l = Sequence {1, 2, 3, 4, 5, 6, 7}

      f = M.tail

  - context with bad arguments:
      badargs.diagnose (f, "prototype.sequence.tail (Sequence)")

  - context as a module function:
    - it returns a Sequence object:
        expect (objtype (f (l))).to_be "Sequence"
    - it makes a new Sequence with the first element removed:
        expect (f (l)).to_equal (Sequence {2, 3, 4, 5, 6, 7})
    - it works for an empty Sequence:
        expect (f (Sequence {})).to_equal (Sequence {})
    - it returns an empty Sequence when passed a Sequence with one element:
        expect (f (Sequence {1})).to_equal (Sequence {})

  - context as an object method:
    - before:
        f = l.tail

    - it returns a Sequence object:
        expect (objtype (f (l))).to_be "Sequence"
    - it makes a new Sequence with the first element removed:
        expect (f (l)).to_equal (Sequence {2, 3, 4, 5, 6, 7})
    - it works for an empty Sequence:
        expect (f (Sequence {})).to_equal (Sequence {})
    - it returns an empty Sequence when passed a Sequence with one element:
        expect (f (Sequence {1})).to_equal (Sequence {})
